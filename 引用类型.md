# 引用类型

## 参数问题

## 往`List`添加元素
对于下面的代码:
```java
public static void main(String[] args) {
    Integer[] a = {1, 1, 1};
    List<Integer[]> list = new ArrayList<>();
    for (int i = 0; i < 1; i++) {
        list.add(a);
    }

    a[0] = 5;

    for (Integer[] integers : list) {
        for (int i = 0; i < 3; i++)
            System.out.println(integers[i]);
    }
}
```
如果运行上面的代码的话,你会发现列表中添加的是:`5, 1, 1`,这是因为往里面添加的是数组`a`的引用,当我们修改`a`里面的内容的时候,列表中也会发生相应的改变。

我们为了避免这种情况,我们可以向里面添加`a.clone`,关于这个方法:
```
 new操作符的本意是分配内存。程序执行到new操作符时，首先去看new操作符后面的类型，因为知
 道了类型，才能知道要分配多大的内存空间。分配完内存之后，再调用构造函数，填充对象的各个
 域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完毕，可以把他的引用（地址）发
 布到外部，在外部就可以使用这个引用操纵这个对象。而clone在第一步是和new相似的，都是分配
 内存，调用clone方法时，分配的内存和源对象（即调用clone方法的对象）相同，然后再使用原对
 象中对应的各个域，填充新对象的域，填充完成之后，clone方法返回，一个新的相同的对象被创
 建，同样可以把这个新对象的引用发布到外部。
```
但其实对于`clone()`来说,这还涉及到**深拷贝**和**浅拷贝**,可以参考这篇写的很详细的博客:
https://blog.csdn.net/zhangjg_blog/article/details/18369201
下面有一个评论也很有意思:
```
博主你好！作为初学者正在研读你的博客，在网上看了其他人关于原型模式的文章，然后觉得你这
里好像有点不足，就是使用一般的clone()方法对对象中的String的克隆应该属于深克隆。原因在于
String的不可变，比如String str = "java";，除非你用反射，否则你无法改变“java”任何一个字
符。所以 ，当克隆的时候把原型对象中的String引用复制给新对象的引用时，虽然新对象和原型指
向相同的内容，但是原型不会影响到克隆对象的内容，从这一角度来说，对String应用的克隆属于
深度克隆。望指正。
```
