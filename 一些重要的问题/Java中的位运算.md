# Java中的位运算

## 移位
1. 左移: <<
```java
public static void main(String[] args) {
    System.out.println(5<<2);//运行结果是20
}
```
> 首先会将5转为2进制表示形式(java中，整数默认就是int类型,也就是32位):
> 0000 0000 0000 0000 0000 0000 0000 0101           然后左移2位后，低位补0：
> 0000 0000 0000 0000 0000 0000 0001 0100           换算成10进制为20

2. 右移: >>
右移( >> ) ，右移同理，只是方向不一样罢了
System.out.println(5>>2);                 //运行结果是1
> 还是先将5转为2进制表示形式：
> 0000 0000 0000 0000 0000 0000 0000 0101 然后右移2位，高位补0：
> 0000 0000 0000 0000 0000 0000 0000 0001
但其实这是对正数来说是这样的,对于负数来说,会首先补0.

这里需要声明的是:不论对于十进制数还是对于十六进制数,全部都是以补码的形式,对于`0x80000001`来说,计算机会直接将它的二进制表示出来,也就是`1000 0000 0000 0000 0000 0000 0000 0001`,就直接将其当作二进制补码将其存储进去,这样的话,如何求解其对应的十进制值,一种方案就是将其直接转化为原码,第一位为符号位,转化方法为:符号位不动,其余位取反之后,最后一位再加1,转化为:`1111 1111 1111 1111 1111 1111 1111 1111`,最后将第一位视为符号位,最后计算出值为:`-2147483647`,但是这种做法会有一个很大的弊端,不能说是错误,即如何计算`1000 0000 0000 0000 0000 0000 0000 0000`,因为在计算它的时候会出现溢出的情况,最后转化为原码为`0000 0000 0000 0000 0000 0000 0000 0000`,但其实有一个溢出的1,我觉得可以从这个角度解释:已经有`0000 0000 0000 0000 0000 0000 0000 0000`来表示0,所以可以让`1000 0000 0000 0000 0000 0000 0000 0000`来表示`-2147483648`。

3. 无符号右移: >>>
`-5`在计算机中表示为:`1111 1111 1111 1111 1111 1111 1111 1011`,如果让`-5`向右移`3`位,得到结果:`1111 1111 1111 1111 1111 1111 1111 1111`,也就是`-1`。但是我们上面使用的`>>`,现在我们使用`>>>`,即无符号右移,得到结果:`0001 1111 1111 1111 1111 1111 1111 1111`,即:536870911。
使用无符号右移`>>>`对负数进行操作的时候,得不到想要的结果,但是对于正数来说,却可以防止溢出错误,比如下面的代码:
```java
Integer i = Integer.MAX_VALUE;
Integer j = Integer.MAX_VALUE;
System.out.println((i + j) >> 1);
System.out.println((i + j) >>> 1);
```
`i`和`j`的原码和补码相同,都为`0111 1111 1111 1111 1111 1111 1111 1111`,当他们相加的时候,会得到结果`(0) 1111 1111 1111 1111 1111 1111 1111 1111 1111`前面的`(0)`是溢出位,实际上计算机认为这是个负数,但是当我们向无符号右移的时候,又可以将这个`0`移回来,又能够重新表示正数,并且能够保证结果正确。


## 位与(&)
将两个操作数全部都转化成二进制,第一个操作数的的第n位于第二个操作数的第n位如果都是1，那么结果的第n位也为1，否则为0。

## 位或(|)
将两个操作数全部都转化成二进制,第一个操作数的的第n位于第二个操作数的第n位 只要有一个是1，那么结果的第n位也为1，否则为0。

## 位异或(^)
将两个操作数全部都转化成二进制,第一个操作数的的第n位于第二个操作数的第n位 相反，那么结果的第n位也为1，否则为0。

## 位非(~)
一元运算符,操作数的第n位为1，那么结果的第n位为0，反之。