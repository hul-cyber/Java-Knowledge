#  JVM类加载

## JAVA类加载过程

1、通过C++实现代码，调用windows下的java.exe，调用jvm.dll，创建java虚拟机

2、创建一个引导类加载器实例（c++实现）

3、C++调用java代码，创建 JVM启动器实例，sun.mis.cLauncher，该类由类加载器负责加载，创建其他类加载器（JVM有很多类加载器） 

4、sun.misc.Launcher.getLauncher()，获取运行类自己的加载器ClassLoader，是AppClassLoader的实例。

5、launcher.getClassLoader(),调用loadClass加载要运行的类Math。

6、运行用户类代码

7、JVM销毁。

![1608709202469](assets/1608709202469.png)

## 类加载过程

加载、验证、准备、解析、初始化。

1、加载：将字节码文件放入内存。

2、验证：***cafe babe*** 标准字节码开头文件。在类加载时，会先验证一下字节码的规范。

3、准备：会把静态变量初始赋值（int 为0 boolean为false），这个初始值是jvm规定的，并不会改变。（如果加了final，则变为常量，直接赋值入虚拟机）

4、解析：将符号引用替换为直接引用。（符号，例如类名，方法名等等。将这些符号替换内存指针或者句柄），这就是所谓的静态链接（动态链接是在程序运行期间将符号引用替换为直接引用。）

5、 初始化：把静态变量初始化为对应的值（初始化之前，静态变量都是默认值）类被加载到方法区中后，主要包含***运行时常量池，类型信息，字段信息，方法信息，类加载器的引用，对应class实例的引用***等等。



JVM的类加载机制，其实是一种***懒加载***

 

 ### 类加载器和双亲委派

***引导类加载器***：位于JDK lib目录下，由C++编写，用于加载支撑JVM运行的rt.jar（java.nio,java.time,java.util等工具类，都在rt.jar中) charsets.jar等类）

***扩展类加载器***：负责加载支撑JVM运行的，位于JRE exrt目录下的jar包

***应用程序加载器***：负责加载ClassPath路径下的类，主要是加载你自己写的那些类。

***自定义加载器***：负责加在用户自定义路径下的类

***所有类加载器，都继承与ClassLoader类，没个类加载器都有一个参数parent，标定了类加载器的父亲（与双亲委派有关，但并不是父类）。***

Launcher类初始化过程：获取ExtClassLoader（父类为URLClassLoader），AppClassLoader（***传入ExtClassLoader作为参数，父类也为URLClassLoader，但其parent，为传入的ExtClassLoader***）。

引导类加载器通过C++代码加载，然后引导类加载器加载ExtClassLoader与AppClassLoader，同时构造两个类加载器的父级关系（通过parent属性）

ExtClassLoader的parent是BootStrapLoader是null，因为引导类加载器是通过C++加载进来的，并不存在JVM中

***双亲委派机制*** ：

![1609143223869](assets/1609143223869.png)

在没有自定义加载器的时候，一个类会先请求应用程序加载器AppClassLoader加载，

​	AppClassLoader扫描自己已经加载的类，如果有则返回，若没有，则委托parent加载，AppClassLoader委托ExtClassLoader。ExtClassLoader进行相同的操作，若不在自己的已加载列表中，则委托parent，引导类加载器 BootStrapClassLoader。BootStrapClassLoader发现这个类不在自己已加载列表里，会尝试从JDK,lib文件夹中加寻找这个类加载（引导类加载器只负责加载JDK lib文件夹下的加载器）。若没有，则向下委派扩展类加载器去加载。扩展类加载器扫描ext文件夹，若无则委托AppClassLoader。AppClassLoader会扫描target目录下（如果是IDEA的话），则必然找到，加载（调用LoadClassPath()方法）。

###为什么要从AppClassLoader开始先向上委托？

​	对于一个web项目来说，95%以上的类，都是由AppClassLoader进行加载的，而且很多类会重复加载非常多次。如果每次都从引导类开始向下委派，无疑效率很低。直接请求AppClassLoader，若存在则返回，会大大提高效率。仅仅类第一次加载的时候效率会较低而已。

### 为什么要设计双亲委派机制

​		1、沙箱安全机制：避免底层API类被修改，影响安全性。

例如： 我们构建一个类叫java.lang.String.class，这个类与JDK的String同名。在加载这个类的时候，会先向上委托到BootStrapClassLoader，返回java本身的API类String，并不会加载你实际写的这个类。保证了java.lang.String只会加载JDK的API类而非同名自定义类。防止核心API库被修改。

​		2、避免类的重复加载：当父加载器已经加载过某个类，例如ExtClassLoader已经家在过这个类了，那么会直接返回这个类，不会让AppClassLoader再加载一次。





全盘委托机制：如果一个A类加载的时候使用AppClassLoader，A引用了B，则B也会由AppClassLoader加载，不会由其他类加载器加载。

### 实现自定义类加载器

自定义类加载器，主要是通过继承java.lang.ClassLoader类。该类有两个核心方法，一个是loadClass（String，boolean），实现了双亲委派。另一个是findClass，默认是空方法，我们自定义类加载器，主要是实现findClass方法。

findClass主要是把对应的类通过file操作，读取到一个字节数组中，然后传入defineClass函数中。

***为什么自定义类加载器的父加载器是AppClassLoader***

类加载器的父类ClassLoader，在构造方法中会默认将AppClassLoader赋值给parent。

### 打破双亲委派机制

由于双亲委派机制是通过java.lang.ClassLoader的 LoaderClass函数完成的，打破双亲委派，就重写这个函数就可以了。

可能会遇到，比如所有类都继承于Object，如果所有类都打破双亲委派，用自定义加载器记载，会出现Object类家在不到的情况。所以要将API类的加载过滤掉，API类依旧遵循双亲委派，自己实现的类打破双亲委派。 

### TOMCAT打破双亲委派机制

![1609226689679](assets/1609226689679.png)

方框中的加载器，是加载Tomcat的公共jar包，包括我们可能常用的servlet等等。tomcat7之后，上面方框中的三个加载器合并为一个

不再分目录，所有tomcat的公共jar都放在lib中了。



Tomcat上的每个war包，都会有一个对应的WebappClassLoader（他不是生成了一个新的ClassLoader类，是通过类，new了一个webClassLoader对象，通过这个对象加载类。），保证了项目之间的类的隔离（JVM区分相同类，除了包名、类名，还要看加载器是否 相同）。项目自己的类，自己用WebappClassLoader，项目中引用的tomcat公用类，还是委托上级加载。

 

#JVM内存模型

![1609378328084](assets/1609378328084.png)

***栈***：一旦一个线程开始运行，就会在栈内开辟一块空间，供当前线程使用的局部变量。

***栈帧***：只要某个线程开始运行一个方法，就会在这个线程的栈空间分配一块栈帧，用于存储这个方法运行时的一些***局部变量表，操作数栈，动态链接，方法出口***。没个方法都会对应自己独立的栈帧。

栈内放置栈帧的结构，与数据结构中的栈相同，First in Last out。按照程序调用顺序，后调用先执行。后分配的内存空间，会先被释放。

  ***程序计数器***：每个线程独有，用于存放下一行要执行的代码的对应内存位置或行号。每执行完一行代码，字节码执行引擎都会修改程序计数器的数值。

***程序计数器作用***：在多个线程并行的时候，会出现线程抢占CPU时间片的情况，当前线程会挂起。当从挂起恢复到运行态的时候，会从程序计数器中读取下一行要执行代码的位置，从而继续完成线程 。

***操作数栈***：存放当前要使用的操作数

***动态链接***：存放一些调用函数的内存位置。

***方法出口***：根据方法出口，确定当前函数执行完之后，下个函数要从哪开始执行。例如（Main调用了A函数，A函数执行完，需要从方法出口获取继续从Main函数的哪个位置调用）。

***局部变量表***：存放函数中的局部变量。如果局部变量为对象，则局部变量表中存储对象的地址。

 

***方法区***：常量池，存放常量+静态变量+类元信息

***本地方法栈***：用于存放native方法调用的dll库之类的类库所需要的内存。

***堆***：我们New出来的对象，一般会放在Eden区，当Eden存满之后，会先进行Minor gc，字节码执行引擎会启动一个gc线程，对Eden进行Minor gc。

***STW***: 一旦Old区满了，JVM就会触发FullGC，防止OOM，当触发FullGC的时候，JVM会停止所有用户线称的运行，执行GC线程。

***为什么要设计STW***:在GC的过程中，基本以Root为根节点进行可达性分析为基本原则，但如果不STW，用户线程还在执行和结束，会造成本来非垃圾的数据，在用户进程运行的过程中突然变成垃圾数据，从而导致GC清理永远没办法清理干净。

###JVM内存参数。

![1609398538089](assets/1609398538089.png)

Spring Boot程序的JVM参数设置格式(Tomcat启动直接加在bin目录下catalina.sh文件里)：
1 java ‐Xms2048M ‐Xmx2048M ‐Xmn1024M ‐Xss512K ‐XX:MetaspaceSize=256M ‐XX:MaxMetaspaceSize=256M ‐jar microservice‐eurek
a‐server.jar
关于元空间的JVM参数有两个：-XX:MetaspaceSize=N和 -XX:MaxMetaspaceSize=N
-XX：MaxMetaspaceSize： 设置元空间最大值， 默认是-1， 即不限制， 或者说只受限于本地内存大小。
-XX：MetaspaceSize： 指定元空间触发Fullgc的初始阈值(元空间无固定初始大小)， 以字节为单位，默认是21M，达到该值就会触发
full gc进行类型卸载， 同时收集器会对该值进行调整： 如果释放了大量的空间， 就适当降低该值； 如果释放了很少的空间， 那么在不超
过-XX：MaxMetaspaceSize（如果设置了的话） 的情况下， 适当提高该值。这个跟早期jdk版本的-XX:PermSize参数意思不一样。

***如果一个War包 几百M甚至几G，启动要启动数分钟， 很有可能是没有设置方法区大小，它默认就是21M，然后每次满了就触发FullGC，相当浪费时间***

XX:PermSize代表永久代的初始容量。
由于调整元空间的大小需要Full GC，这是非常昂贵的操作，如果应用在启动的时候发生大量Full GC，通常都是由于永久代或元空间发生
了大小调整，基于这种情况，一般建议在JVM参数中将MetaspaceSize和MaxMetaspaceSize设置成一样的值，并设置得比初始值要大，
对于8G物理内存的机器来说，一般我会将这两个值都设置为256M。







###New方法执行过程（对象的创建流程） 

![1609402272592](assets/1609402272592.png)

***1、类的检查***：虚拟机在遇到一条New指令的时候，首先会去检查这个指令的参数能否在常量池定位到一个类的符号引用，并且判断***这个类是否已经被加载，解析，初始化***。如果没有，则执行类加载过程，如果有，则分配内存。

***2、分配内存***：类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存的大小在类加载后便可以完全确定。所以分配内存只存在两个问题：

1、如何划分内存

2、在并发情况下，可能出现正好给对象A分内存但指针还没修改，对象B又同时使用原来的指针分配内存的情况。

解决方法：

###内存划分

1、指针碰撞（默认使用指针碰撞方法）：如果JAVA堆中的内存是绝对规整的，那么我们新分配的对象只需要在空闲内存和已使用内存中间的分界点上划分出一块空间，并将分界点指针移动相同大小即可。

2、空闲列表：如果虚拟机上的堆内存是不连续的，那么就需要虚拟机维护一份空闲内存表，记录那些内存快是可用的，从而在列表中找到一块足够大的内存分配给对象。

***并发问题***

1、CAS：虚拟机采用***CAS+失败重试***  的方式来保证操作的原子性来对分配内存空间的动作进行同步处理。

2、本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）

把内存分配，按照每个线程，提前分配一块内存空间。线程创建的对象会首先向线程对应的内存空间中存储。JAVA8默认采用TLAB，可以通过-XX:+/-UseTLAB 来设定虚拟机是否使用TLAB，-XX:TLABSize指定TLAB大小。如果TLAB放不下，则继续走CAS。

***初始化***

对已经分配内存空间的变量，赋初值。

***设置对象头***

![img](assets/clipboard.png)

由于分代年龄只有四位，所以最高到15。这也就是为什么标记回收会标记15次才进入老年代。

***KlassPointer***（就是Klass，是JVM中C++类的指针）类指针（开启压缩占用4字节，关闭压缩占用8字节）指向类元信息（在方法区中）

Class类对象与类元信息的区别：类内的代码等信息，是作为类元信息放在方法区的，而Class对象 是JVM给予开发者的对象，为了让程序员获取类的相关信息。但是在JVM实际运行的时候，一般都会通过类型指针去找类元信息进行运行（实际上的类元信息，是C++对象存储的，提供JVM直接使用，而不是Class对象的那种JAVA对象）。



如果是数组对象的话，对象头还会存储数组长度。

 ***Init***

调用init方法（并不是构造方法）， C++内部调用，会将赋初值的对象赋为具体值、  



***指针压缩*** 

1.jdk1.6 update14开始，在64bit操作系统中，JVM支持指针压缩
2.jvm配置参数:UseCompressedOops，compressed压缩、oop(ordinary object pointer)对象指针
3.启用指针压缩:XX:+UseCompressedOops(默认开启)，禁止指针压缩:XX:UseCompressedOops

如果不开启指针压缩，对象的对象头中，大量8bit的指针，会无形中占用大量的堆空间，提高GC的频率。JDK1.6之后，JVM默认开启指针压缩。

***为什么要进行指针压缩？***

1.在64位平台的HotSpot中使用32位指针，内存使用会多出1.5倍左右，使用较大指针在主内存和缓存之间移动数据，
占用较大宽带，同时GC也会承受较大压力
2.为了减少64位平台下内存的消耗，启用指针压缩功能
3.在jvm中，32位地址最大支持4G内存(2的32次方)，可以通过对对象指针的压缩编码、解码方式进行优化，使得jvm只用32位地址就可以支持更大的内存配置(小于等于32G)
4.堆内存小于4G时，不需要启用指针压缩，jvm会直接去除高32位地址，即使用低虚拟地址空间
5.堆内存大于32G时，压缩指针会失效，会强制使用64位(即8字节)来对java对象寻址，这就会出现1的问题，***所以堆内存不要大于32G为好***



###对象内存分配

![img](assets/327202027172.png)

并不是所有对象都直接分配在堆中。

  ***对象分配到栈的情况***

```
public User test1() {
   User user = new User();
   user.setId(1);
   user.setName("zhuge");
   //TODO 保存到数据库
   return user;
}

public void test2() {
   User user = new User();
   user.setId(1);
   user.setName("zhuge");
   //TODO 保存到数据库
}
```

如上面函数test1，在test1中生成的对象，会return出去，有可能被其他函数所引用，所以这个对象逃逸出了这个方法。

test2方法中的user对象，并不会被test2函数之外的方法或对象引用，所以它并未逃逸出方法。

***JVM可以将未逃逸出方法的对象，分配在栈帧内（对象不太大，栈帧内空间足够）***，栈帧内的对象会随着方法的结束而消亡，并不会一直存在与堆内，减轻了GC的压力。

开启逃逸分析参数：-XX:+DoEscapeAnalysis (JDK7之后默认开启)

***标量替换***：通过***逃逸分析***确定一个对象不会逃逸时，且栈帧内空间足够的情况下，JVM会试图将对象分配在栈帧内。但是栈帧内的内存不一定是连续的，而常规对象需要一个连续的内存空间。所以JVM会进行***标量替换***，即：将该对象分解成若干个被当前方法引用的成员变量，分配在栈帧内，从而合理利用碎片空间。

开启标量替换参数：-XX:+EliminateAllocations  JDK7之后默认开启



***对象在Eden分配***

**Eden与Survivor区默认8:1:1**

如果大对象(-XX:PretenureSizeThreshold=1000000 通过这个参数修改，要与 -XX:+UseSerialGC 收集器配合使用)，直接去Old。不是说除了SerialGC和ParNew之外，大对象就不去老年代，而是G1收集器等对老年代有自己的定义。

如果不是，则先进行TLAB分配（在线程独占的堆空间内分配），如果还是不行，就CAS分配。 

**为什么要设置大对象进老年代？**

为了避免为大对象分配内存时的复制操作而降低效率。

**对象动态年龄判断机制**

做完MinorGC，如果放入survivor区的对象超过了Servier区50%，那么就会被直接放入Old。（如果一批对象，会按照年龄1+年龄2+。。。。+年龄N，如果刚好超过50%，就会把年龄N及以上（>=N)的放入老年代，其他的放入Survivor区。本质思想是让存活比较久的对象尽早进入Old。）

**老年代分配担保机制**：

在MinorGC之前，会触发老年代分配担保机制。

![1609749730937](assets/1609749730937.png)

### 调优实例

![1609746733782](assets/1609746733782.png)

一张表几十个字段，大概估算在1k上下一个对象

所以每秒大概300K的对象分配到堆中。如果可能一个订单还涉及其他10-20个功能模块，预计估算一个下单流程大概要20-30K上下。如果同时还要有查询等大数据量操作，我们放大十倍，每秒大概有60M对象放入Eden。

这60M基本会在1S之后变为垃圾对象。

![1609747870844](assets/1609747870844.png)

这是一个，根据内存来分配的初步模型，基本不懂行的人都会这么瞎分配。

***问题分析***：

1、以每秒60M对象存入来算，Eden 14S填满。当触发MinorGC的时候会产生STW。但是第14S 还在运行线程引用的60M对象不会被GC，所以会被移动到S0。

2、根据对象年龄动态判断机制，60M>100*50% 所以会直接放入Old。每过14S，就会有60M的对象进入Old。8分钟左右，Old就会被存满然后FullGC。

这种情况下，频繁FullGC的归根结底的原因，就是大量朝生夕死的对象被**动态年龄机制**放入Old。

***解决方法***：

1、扩大年轻代，将年轻代扩大到2G，也就是1.6G:200M:200M，这样每次GC的时候基本都会将Eden的全部清除干净，只留下60M当前一秒的数据，这些数据不满足动态年龄判断的survivor的50%，所以基本不会向老年代放入。





### 对象内存回收



1、可达性分析：前面有写

2、引用计数器：一个对象如果有一个引用指向它，这个对象内部会有一个引用计数器，计数器就会+1。如果计数器是0，就被回收。

3、一个对象执行finilize，只会执行一次，自救也只能自救一次。



**如何判断一个类是无用类**

方法区回收，主要是回收无用类的类元信息。

类需要满足三个条件在能算是无用类：

1、该类的所有实例都已经被回收，java堆中也不存在该类的实例。

2、加载该类的ClassLoader已经被回收

3、该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。