# 面向对象编程
这里主要讲解面向对象编程的三大特性:继承、多态、封装.总结的并不详细,只是记录了一些比较重要的知识点,很多琐碎内容没有记录。具体内容请参考:https://how2playlife.com/2019/09/01/1%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/

## 继承

### 权限限定符
![](2020-10-06-08-27-25.png)
也就是从private -> public,作用域会变得越来越大,但是在子类中只能够将权限限定符变大或者不变。

### 方法的重写
子类可以修改继承下来的方法,这被叫做重写,但是要注意的是:**必须要保证方法名相等,返回值相等,参数类型与参数个数相等.**
重写和重载的比较:
重写:相对于继承而言,子类对从父类继承来的方法进行修改。
重载:在同一个类中,多个具有相同的方法名,但是他们的参数不相同(包括参数类型、参数个数、参数顺序)。但是不包括返回类型,也就是是说如果方法名,参数完全相同,但是返回类型不相同的话,不会被认为是重载,事实上,Java会认为这是完全相同的方法,所以会出现编译错误,只有方法名和参数被叫做签名,用来区分两个方法。

### 继承的初始化顺序
这个在类的初始化中会有更加详细的论述,这里先简单地讨论一下:
1. 首先初始化父类,之后初始化子类。
2. 先初始化对象中的属性,再执行构造方法的初始化。

也就是说:
> 父类对象属性初始化—->父类对象构造方法—->子类对象属性初始化—>子类对象构造方法

### final关键字
1. final 修饰类，则该类不允许被继承。
2. final 修饰方法，则该方法不允许被覆盖(重写)。
3. final 修饰属性，则该类的该属性不会进行隐式的初始化，所以 该final 属性的初始化属性必须有值，或在构造方法中赋值(但只能选其一，且必须选其一，因为没有默认值！)，且初始化之后就不能改了，只能赋值一次。
4. final 修饰变量，则该变量的值只能赋一次值，在声明变量的时候才能赋值，即变为常量。

### super关键字
在对象的内部使用,可以代表父类对象。
`super`关键字和`this`关键字很相似,但其实两者有差异,`this`代表调用该方法的对象的引用,可以将其赋值给其它的对象变量,但是`super`却不能这样,只是一个指示编译器调用超类方法的关键字。

## 封装
封装的相关内容见上面提到的博客。

## 多态

### 引用多态
父类的引用可以指向本类的对象；
父类的引用可以指向子类的对象

### 方法多态
根据上述创建的两个对象：本类对象和子类对象，同样都是父类的引用，当我们指向不同的对象时，它们调用的方法也是多态的。

创建本类对象时，调用的方法为本类方法；

创建子类对象时，调用的方法为子类重写的方法或者继承的方法；

使用多态的时候要注意：如果我们在子类中编写一个独有的方法（没有继承父类的方法），此时就不能通过父类的引用创建的子类对象来调用该方法！！！

注意： 继承是多态的基础。

### 引用类型转化
```java
public class Animal {
    
}
```
```java
public class Dog extends Animal {

}
```
```java
public class Cat extends Animal {

}
```
```java
public static void main(String[] args) {
    //向上转型
    Animal a = new Dog();
    //向下转型
    Dog dog1 = (Dog) a;
    //能通过编译,但运行会出现问题
    //Dog dog2 = (Dog) new Animal();
    Cat cat = (Cat) a;
}
```
首先向上转型肯定完全没有问题,主要分析向下转型:
直接调用`Dog dog = new Animal()`肯定过不了编译,我们肯定应该用到强制转换,`Dog dog = (Dog) new Animal()`,这样的话,能够通过编译,但运行时肯定会出现错误,但是如果这样的话,肯定不会出现错误:`Animal a = new Dog(); Dog dog1 = (Dog) a;`,因为这里的这个对象变量`a`实际上指向一个`Dog`。
还有一种情况:父类的引用指向其他子类的对象，则不能通过强制转为该子类的对象。比如向下面这样:
```java
Animal a = new Dog();
Cat cat = (Cat) a;
```

### `instanceof`运算符
`instanceof`是Java的一个二元操作符，和==，>，<是同一类东东。由于它是由字母组成的，所以也是Java的保留关键字。它的作用是测试它左边的对象是否是它右边的类的实例，返回`boolean`类型的数据。
```java
public static void main(String[] args) {
    //向上转型
    Animal a = new Dog();
    //向下转型
    Dog dog1 = (Dog) a;
    //能通过编译,但运行会出现问题
    //Dog dog2 = (Dog) new Animal();
    if (a instanceof Cat) {
        Cat cat = (Cat) a;
        System.out.println("cat");
    }
    if (a instanceof Dog) {
        Dog dog = (Dog) a;
        System.out.println("dog");
    }
}
```
在比较一个对象是否和另一个对象属于同一个类实例的时候，我们通常可以采用instanceof和getClass两种方法通过两者是否相等来判断，但是两者在判断上面是有差别的。Instanceof进行类型检查规则是:你属于该类吗？或者你属于该类的派生类吗？而通过getClass获得类型信息采用==来进行检查是否相等的操作是严格的判断,不会存在继承方面的考虑。比如下面的例子,使用`getClass()`的话,判断起来很严格,他就认为对象变量`a`是Dog类对象的引用,但是对于`instanceof`来说,他会认为不仅仅是`Dog`类对象的引用,还可能是`Animal`对象的引用。
```java
public static void main(String[] args) {
    //向上转型
    Animal a = new Dog();
    //向下转型
    Dog dog1 = (Dog) a;
    //能通过编译,但运行会出现问题
    //Dog dog2 = (Dog) new Animal();
    if (a.getClass().getName() == "com.demo4.Cat") {
        Cat cat = (Cat) a;
        System.out.println("cat");
    }
    if (a.getClass().getName() == "com.demo4.Dog") {
        Dog dog = (Dog) a;
        System.out.println("dog");
    }
    if (a.getClass().getName() == "com.demo4.Animal") {
        Dog dog = (Dog) a;
        System.out.println("animal");
    }
    if (a instanceof Animal) {
        System.out.println("instance");
    }
}
```
**在写程序的时候，如果要进行类型转换，我们最好使用instanceof运算符来判断它左边的对象是否是它右边的类的实例，再进行强制转换。**

## 重写和重载 
重写是由于继承关系中的子类有一个和父类同名同参数的方法，会覆盖掉父类的方法。重载是因为一个同名方法可以传入多个参数组合。

注意，同名方法如果参数相同，即使返回值不同也是不能同时存在的，编译会出错。

从jvm实现的角度来看，重写又叫运行时多态，编译时看不出子类调用的是哪个方法，但是运行时操作数栈会先根据子类的引用去子类的类信息中查找方法，找不到的话再到父类的类信息中查找方法。

而重载则是编译时多态，因为编译期就可以确定传入的参数组合，决定调用的具体方法是哪一个了。
## 补充内容:
### 向上转型、向下转型与重写
> Father f1 = new Son(); // 这就叫 upcasting （向上转型)
// 现在f1引用指向一个Son对象
Son s1 = (Son)f1; // 这就叫 downcasting (向下转型)

我们现在将上面两部分内容综合起来,在向上转型、向下转型中讨论方法的重写问题。首先我们要明白,转型指的是左侧引用的改变,如果一个父类引用指向一个子类实例,就是向上转型。见我们下面的例子:
```java
public class Animal {
    public void eat() {
        System.out.println("eat");
    }
}
```
```java
public class Bird extends Animal {
    public void fly() {
        System.out.println("fly");
    }
    @Override
    public void eat() {
        System.out.println("eat bug");
    }
}
```
```java
//向上转型
Animal a = new Bird();
//不能调用子类的特有方法
a.fly();
//能调用子类父类共有的方法,如果子类重写,那么会调用子类中的方法,正如我们前面提到的那样,重写又叫做运行时多态,所以在运行时会根据引用去相应的类信息中找到相应的方法。
//这里的eat会调用子类Bird中的方法,因为引用a指向Bird类的对象。
a.eat();
Animal b = new Animal();
//这里的eat会调用父类Animal中的方法,因为引用b指向Animal类的对象。
b.eat();
//向下转型
Bird b2 = (Bird) a;
//能够正常调用继承下来的和独有的方法
b2.eat();
b2.fly();
```
向下转型分为两种情况:
1. 如果父类引用指向的是子类对象:那么这样的转型是安全的,编译和运行都不会出现错误
2. 如果父类引用指向的是父类对象:这样的转型不安全,尽管能通过编译,但是运行会出错

关于向上转型与向下转型的应用:
其实可以用于方法参数中的类型聚合，然后具体操作再进行分解。
```java
public static void add(List list) {
    //比如add方法用List引用类型作为参数传入，传入具体类时经历了向上转型
    System.out.println(list);
    //在操作具体集合时又经历了向下转型
    ArrayList arr = (ArrayList) list;
    LinkedList link = (LinkedList) list;
}
```
**向上转型和向下转型都是针对引用的转型，是编译期进行的转型，根据引用类型来判断使用哪个方法。并且在传入方法时会自动进行转型（有需要的话）。运行期将引用指向实例，如果是不安全的转型则会报错，若安全则继续执行方法。**

### 编译期的静态分派和静态分派
静态分派:
根据变量的「静态类型(外观类型)」(引用类型)匹配调用方法的过程称为静态分派。发生的场景为方法重载。
```java
public class StaticDispatch {

    static abstract class Human { }
    static class Man extends Human { }
    static class Woman extends Human { }
    static class Child extends Human { }

    public void say(Human human) {
        System.out.println("human");
    }

    public void say(Man man) {
        System.out.println("man");
    }

    public void say(Woman woman) {
        System.out.println("woman");
    }

    public void say(Child child) {
        System.out.println("child");
    }
}
```
```java
public static void main(String[] args) {
    Human man = new Man();
    Human woman = new Woman();
    Human child = new Child();

    StaticDispatch dispatch = new StaticDispatch();
    dispatch.say(man);
    dispatch.say(woman);
    dispatch.say(child);
}
```
运行结果为:
```
human
human
human
```
我个人认为下面这种情况也应该被归为静态分派的范畴:
```java
Father father = new Son();
//play()是Son中的特有方法
father.play();
```
上面的问题会在编译期报错,因为编译期会将`father`认为是父类对象变量,但实际上它指向子类对象。
动态分派:
根据变量的「实际类型」匹配调用方法的过程称为动态分派。发生的场景为方法重写。当调用一个可能被子类重写或继承的方法时，就会触发动态分派。
```java
public class DynamicDispatch {

    static class Human {
        public void say() {
            System.out.println("human");
        }
    }

    static class Man extends Human {
        @Override
        public void say() {
            System.out.println("man");
        }
    }

    static class Woman extends Human {
        @Override
        public void say() {
            System.out.println("woman");
        }
    }
}
```
```java
public static void main(String[] args) {
    Human human = new Human();
    Human man = new Man();
    Human woman = new Woman();
    human.say();
    man.say();
    woman.say();
}
```
运行结果为:
```
human
man
woman
```
### 方法重载匹配优先级
```java
public class Demo {
    public static void main(String[] args) {
        Demo a = new Demo();
        //方法重载优先级匹配 a = new 方法重载优先级匹配();
        //普通的重载一般就是同名方法不同参数。
        //这里我们来讨论当同名方法只有一个参数时的情况。
        //此时会调用char参数的方法。
        //当没有char参数的方法。会调用int类型的方法，如果没有int就调用long
        //即存在一个调用顺序char -> int -> long ->double -> ..。
        //当没有基本类型对应的方法时，先自动装箱，调用包装类方法。
        //如果没有包装类方法，则调用包装类实现的接口的方法。
        //最后再调用持有多个参数的char...方法。
        a.eat('a');
        a.eat('a','c','b');
    }
    public void eat(short i) {
        System.out.println("short");
    }
    public void eat(int i) {
        System.out.println("int");
    }
    public void eat(double i) {
        System.out.println("double");
    }
    public void eat(long i) {
        System.out.println("long");
    }
    public void eat(Character c) {
        System.out.println("Character");
    }
    public void eat(Comparable c) {
        System.out.println("Comparable");
    }
    public void eat(char ... c) {
        System.out.println(Arrays.toString(c));
        System.out.println("...");
    }

//    public void eat(char i) {
//        System.out.println("char");
//    }
}
```